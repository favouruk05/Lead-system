<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lead Scraper & Manager</title>
<style>
  * { box-sizing: border-box; }
  :root{
    --accent:#7e3ace; --accent-2:#9c5df0; --accent-3:#b892ff;
    --bg:#f7f5fb; --card:#fff; --text:#1f2330; --muted:#6b7280; --border:#e5e7eb;
    --ok:#16a34a; --warn:#92400e; --err:#b91c1c;
  }
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif; background:var(--bg); color:var(--text); margin:0; padding:12px; font-size:14px; line-height:1.4; }
  .wrap { max-width:100%; margin:0 auto; display:flex; flex-direction:column; gap:16px; }
  .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px; box-shadow:0 1px 3px rgba(0,0,0,0.06); }
  h1 { font-size:20px; margin:0 0 8px 0; font-weight:700; line-height:1.2; }
  .subtitle { color:var(--muted); margin-bottom:16px; font-size:14px; }
  label { display:block; font-size:13px; color:var(--muted); margin-bottom:6px; font-weight:500; }
  input[type=text]{ width:100%; padding:12px; border:1.8px solid var(--border); border-radius:10px; font-size:16px; background:#fff; -webkit-appearance:none; }
  input[type=text]:focus{ outline:none; border-color:var(--accent); box-shadow: 0 0 0 3px rgba(126,58,206,.12); }
  .form-group{ margin-bottom:16px; }
  .button-row{ display:flex; gap:8px; flex-wrap:wrap; }
  .btn{ flex:1; min-width:120px; padding:12px 16px; border:2px solid var(--accent); background:var(--accent); color:#fff; border-radius:10px; cursor:pointer; font-size:14px; font-weight:700; text-align:center; transition:all .16s; }
  .btn:active{ transform:translateY(1px); }
  .btn.secondary{ background:#fff; color:var(--accent); }
  .btn.small{ flex:none; min-width:auto; padding:6px 12px; font-size:12px; font-weight:600; }
  .table-wrapper{ overflow-x:auto; -webkit-overflow-scrolling:touch; margin:-16px; padding:16px; }
  table{ width:100%; min-width:600px; border-collapse:collapse; font-size:13px; }
  th,td{ padding:12px 8px; text-align:left; border-bottom:1px solid var(--border); vertical-align:top; }
  th{ background:var(--bg); font-weight:700; color:var(--text); position:sticky; top:0; }
  .batch-id{ font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; color:var(--muted); }
  .badge{ display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:700; background:var(--bg); border:1px solid var(--border); letter-spacing:.2px; }
  .badge.completed{ background:#dcfce7; color:#166534; border-color:#bbf7d0; }
  /* PROCESSING stays yellow */
  .badge.processing{ background:#fef3c7; color:#92400e; border-color:#fde68a; }
  .actions{ display:flex; gap:4px; flex-wrap:wrap; }
  .link{ color:var(--accent); text-decoration:none; font-weight:600; }
  .link:hover{ text-decoration:underline; }
  .empty-state{ text-align:center; padding:32px 16px; color:var(--muted); }

  @media (min-width:768px){
    body{ padding:24px; font-size:14px; }
    .wrap{ max-width:1200px; margin:0 auto; gap:24px; }
    .card{ padding:24px; }
    h1{ font-size:24px; margin-bottom:12px; }
    .subtitle{ font-size:16px; margin-bottom:24px; }
    input[type=text]{ font-size:14px; padding:10px 12px; }
    .form-grid{ display:grid; grid-template-columns:1fr 1fr; gap:16px; }
    .btn{ flex:none; min-width:140px; }
    table{ min-width:700px; font-size:14px; }
    th,td{ padding:12px; }
  }

   /* Toast container */
  .toast-wrap{
    position:fixed; right:16px; top:16px;
    display:flex; flex-direction:column; gap:10px; z-index:9999;
  }

  /* Toast box */
  .toast{
    min-width:260px; max-width:360px;
    background:#fff; border:1px solid #e5e7eb; border-left-width:6px;
    border-radius:12px; padding:12px 14px;
    box-shadow:0 10px 26px rgba(126,58,206,.18);
    display:flex;                 
    flex-direction:column;        
    gap:6px;                      
  }

  /* color accents */
  .toast.info{ border-left-color:#7e3ace }
  .toast.success{ border-left-color:#16a34a }
  .toast.warn{ border-left-color:#f59e0b }
  .toast.error{ border-left-color:#ef4444 }

  /* first row: title + close */
  .toast .head{
    display:flex; justify-content:space-between; align-items:center;
  }
  .toast .title{
    font-weight:700; font-size:14px; color:#1f2330;
    display:flex; align-items:center; gap:8px;
  }
  .toast .x{
    border:none; background:transparent; font-size:16px; cursor:pointer; opacity:.6;
  }
  .toast .x:hover{ opacity:1 }

  /* second row: subtext */
  .toast .desc{
    font-size:13px; color:#4b5563; line-height:1.35;
    margin-top:2px;               
  }

  /* spinner */
  .spin{
    width:14px; height:14px; display:inline-block; border-radius:999px;
    border:2px solid #d1d5db; border-top-color:#7e3ace; animation:sp .8s linear infinite;
  }
  @keyframes sp{ to{ transform:rotate(360deg); } }
 
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Lead Scraper</h1>
    <p class="subtitle">Submit a new search, then manage recent batches below.</p>
    <form id="scrapeForm">
      <div class="form-grid">
        <div class="form-group">
          <label>Business Type</label>
          <input type="text" id="search_term" placeholder="e.g., plumber" required />
        </div>
        <div class="form-group">
          <label>Location</label>
          <input type="text" id="location" placeholder="e.g., Lekki, Lagos" required />
        </div>
      </div>
      <div class="button-row">
        <button class="btn" type="submit" id="scrapeBtn">Scrape 5 Leads</button>
        <button class="btn secondary" type="button" id="refreshBtn">Refresh</button>
      </div>
    </form>
  </div>

  <div class="card">
    <h1>Recent Batches</h1>
    <div class="table-wrapper">
      <table id="batchesTable">
        <thead>
          <tr>
            <th>Batch</th>
            <th>Criteria</th>
            <th>Date</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="card" id="leadsCard" style="display:none;">
    <h1>Leads in Batch</h1>
    <p class="subtitle" id="batchTitle"></p>
    <div class="table-wrapper">
      <table id="leadsTable">
        <thead>
          <tr>
            <th>Name</th>
            <th>Phone</th>
            <th>Website</th>
            <th>Rating</th>
            <th>Reviews</th>
            <th>Address</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<!-- Toast container -->
<div class="toast-wrap" id="toastWrap" aria-live="polite" aria-atomic="true"></div>

<script>
/** ================== CONFIG ================== */
const BASE = 'https://n8n.autocraft.site';

/** ================== CLIENT ID (per-browser isolation) ================== */
function getClientId(){
  let id = localStorage.getItem('client_id');
  if (!id) {
    id = (crypto && crypto.randomUUID) ? crypto.randomUUID()
      : 'cid_' + Math.random().toString(36).slice(2) + Date.now();
    localStorage.setItem('client_id', id);
  }
  return id;
}
const CLIENT_ID = getClientId();

/** ================== Tiny DOM helper ================== */
const h = (tag, attrs={}, ...kids) => {
  const el = document.createElement(tag);
  Object.entries(attrs||{}).forEach(([k,v])=>{
    if (k === 'class') el.className = v;
    else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.slice(2), v);
    else el.setAttribute(k,v);
  });
  kids.forEach(k => {
    if (k == null) return;
    if (typeof k === 'string') el.appendChild(document.createTextNode(k));
    else el.appendChild(k);
  });
  return el;
};

/** ================== Fetch helpers ================== */
async function fetchJSON(url, opts = {}) {
  // add cache-buster to avoid 304 with empty body
  const sep = url.includes('?') ? '&' : '?';
  const finalUrl = `${url}${sep}_=${Date.now()}`;

  const baseOpts = {
    cache: 'no-store',
    headers: { 'Cache-Control': 'no-store', 'Pragma': 'no-cache', ...(opts.headers || {}) },
    ...opts,
  };

  let res = await fetch(finalUrl, baseOpts);

  // If server still returns 304, retry once with a new buster
  if (res.status === 304) {
    res = await fetch(`${url}${sep}_=${Date.now()+1}`, baseOpts);
  }

  if (!res.ok) throw new Error(`HTTP ${res.status}`);

  try { return await res.json(); } catch { return {}; }
}

async function postBestEffort(url, payload) {
  try {
    const res = await fetch(url, {
      method:'POST',
      headers:{'Content-Type':'application/json','Cache-Control':'no-store'},
      body: JSON.stringify(payload),
    });
    let body=null; try { body = await res.json(); } catch {}
    return { ok: res.ok, status: res.status, body };
  } catch (e) {
    return { ok:false, status:0, body:null, error:e.message };
  }
}

/** ================== Toast (top-right, spinner, purple accent) ================== */
(function ensureToastStyles(){
  if (document.getElementById('toast-styles')) return;
  const css = `
  .toast-wrap{position:fixed;right:16px;top:16px;display:flex;flex-direction:column;gap:8px;z-index:9999}
  .toast{min-width:260px;max-width:360px;background:#fff;border:1px solid #e5e7eb;border-left-width:6px;border-radius:10px;
         box-shadow:0 10px 25px rgba(0,0,0,.08);padding:12px 12px 12px 10px;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  .toast .head{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .toast .title{font-weight:700;font-size:14px;color:#1f2330;display:flex;align-items:center;gap:8px}
  .toast .x{border:none;background:transparent;font-size:16px;cursor:pointer;opacity:.6}
  .toast .x:hover{opacity:1}
  .toast .desc{font-size:13px;color:#4b5563;line-height:1.35}
  .toast.info{border-left-color:#7e3ace}
  .toast.success{border-left-color:#16a34a}
  .toast.warn{border-left-color:#f59e0b}
  .toast.error{border-left-color:#ef4444}
  /* spinner */
  .spin{width:14px;height:14px;display:inline-block;border-radius:999px;border:2px solid #d1d5db;border-top-color:#7e3ace;animation:sp .8s linear infinite}
  @keyframes sp{to{transform:rotate(360deg)}}`;
  const s = document.createElement('style'); s.id='toast-styles'; s.textContent = css; document.head.appendChild(s);
})();
function getToastHost(){
  let host = document.querySelector('.toast-wrap');
  if (!host){ host = document.createElement('div'); host.className='toast-wrap'; document.body.appendChild(host); }
  return host;
}
function showToast({title, desc, variant='info', loading=false, autoCloseMs=null}){
  const host = getToastHost();
  const el = document.createElement('div');
  el.className = `toast ${variant}`;
  el.innerHTML = `
    <div class="head">
      <div class="title"></div>
      <button class="x" aria-label="Close">&times;</button>
    </div>
    <div class="desc"></div>`;
  const ttl = el.querySelector('.title');
  if (loading) {
    const sp = document.createElement('span'); sp.className='spin';
    ttl.appendChild(sp);
  }
  const setTitle = (t)=>{ ttl.childNodes.forEach(n=>{ if(n.nodeType===3) ttl.removeChild(n); }); ttl.appendChild(document.createTextNode(t)); if (loading) ttl.insertBefore(ttl.querySelector('.spin'), ttl.firstChild); };
  setTitle(title || '');
  el.querySelector('.desc').textContent = desc || '';
  let timer = null;
  function close(){ if (timer) clearTimeout(timer); el.remove(); }
  el.querySelector('.x').addEventListener('click', close);
  host.appendChild(el);
  return {
    el, close,
    update({title, desc, variant, loading:ld, autoCloseMs}){
      if (title != null) setTitle(title);
      if (desc  != null) el.querySelector('.desc').textContent = desc;
      if (variant){ el.className = `toast ${variant}`; }
      if (ld != null){
        const has = !!el.querySelector('.spin');
        if (ld && !has){ const sp = document.createElement('span'); sp.className='spin'; ttl.insertBefore(sp, ttl.firstChild); }
        if (!ld && has){ el.querySelector('.spin').remove(); }
      }
      if (autoCloseMs != null){
        if (timer) clearTimeout(timer);
        if (autoCloseMs) timer = setTimeout(()=>this.close(), autoCloseMs);
      }
    }
  };
}

/** ================== Batches table ================== */
/* Render table (used for manual refresh + the two controlled refreshes) */
async function loadBatchesAndRender() {
  const tbody = document.querySelector('#batchesTable tbody');
  tbody.innerHTML = '';
  try {
    const data = await fetchJSON(`${BASE}/webhook/ui/batches?client_id=${encodeURIComponent(CLIENT_ID)}`);
    const list = data.data || [];
    list.forEach(b => {
      const actions = h('div', {class:'actions'},
        h('button', {class:'btn small secondary', onclick:()=>showLeads(b)}, 'View'),
        h('button', {class:'btn small secondary', onclick:()=>rerun(b)}, 'Re-run'),
        h('button', {class:'btn small', onclick:()=>delBatch(b)}, 'Delete'),
      );
      const criteria = `${b.search_term} â€“ ${b.location}`;
      const shortId = b.batch_id && b.batch_id.length > 20 ? b.batch_id.substring(0, 20) + 'â€¦' : (b.batch_id || 'â€”');
      const statusRaw = (b.status || '').toLowerCase();
      const statusClass = statusRaw.includes('complet') ? 'completed'
                        : (statusRaw.includes('process') || statusRaw.includes('active') || statusRaw.includes('pending')) ? 'processing'
                        : '';
      tbody.appendChild(h('tr', {},
        h('td', {}, h('span', {class:'batch-id'}, shortId)),
        h('td', {}, criteria),
        h('td', {}, b.date_created ? new Date(b.date_created).toLocaleString() : 'â€”'),
        h('td', {}, h('span', {class:`badge ${statusClass}`}, b.status || 'â€”')),
        h('td', {}, actions),
      ));
    });
    if (list.length === 0) {
      tbody.appendChild(h('tr',{}, h('td',{colspan:'5', class:'empty-state'}, 'No batches found')));
    }
    return list;
  } catch(e) {
    tbody.appendChild(h('tr',{}, h('td',{colspan:'5', class:'empty-state'}, `Error: ${e.message}`)));
    return [];
  }
}
/* Fetch batches silently without re-rendering table */
async function fetchBatchesOnly() {
  try {
    const data = await fetchJSON(`${BASE}/webhook/ui/batches?client_id=${encodeURIComponent(CLIENT_ID)}`);
    return data?.data || [];
  } catch { return []; }
}

/** ================== Leads view ================== */
// helper: render social chips under Website
function socialChips(socials = {}) {
  const wrap = document.createElement('div');
  wrap.style.display = 'flex';
  wrap.style.flexWrap = 'wrap';
  wrap.style.gap = '6px';
  wrap.style.marginTop = '6px';

  const add = (label, url) => {
    if (!url) return;
    const a = document.createElement('a');
    a.href = url;
    a.target = '_blank';
    a.rel = 'noopener';
    a.textContent = label;
    a.className = 'link';
    a.style.fontSize = '12px';
    a.style.padding = '2px 6px';
    a.style.border = '1px solid var(--border)';
    a.style.borderRadius = '999px';
    wrap.appendChild(a);
  };

  add('LinkedIn', socials.linkedin);
  add('Twitter',  socials.twitter);
  add('Facebook', socials.facebook);
  add('Instagram',socials.instagram);

  return wrap.childNodes.length ? wrap : '';
}

async function showLeads(batch) {
  const leadsCard = document.getElementById('leadsCard');
  const title = document.getElementById('batchTitle');
  const tbody = document.querySelector('#leadsTable tbody');

  title.textContent = batch.batch_id || '';
  tbody.innerHTML = '';
  leadsCard.style.display = 'block';

  try {
    const url = `${BASE}/webhook/ui/leads?batch_id=${encodeURIComponent(batch.batch_id)}&client_id=${encodeURIComponent(CLIENT_ID)}`;
    const data = await fetchJSON(url);

    // normalize to array
    let rows = [];
    if (Array.isArray(data)) rows = data;
    else if (Array.isArray(data?.data)) rows = data.data;
    else if (data?.data && typeof data.data === 'object') rows = [data.data];
    else if (data && typeof data === 'object' && (data.id || data.name)) rows = [data];

    rows.forEach(l => {
      const tr = document.createElement('tr');

      // Name
      const tdName = document.createElement('td');
      tdName.textContent = l.name || 'N/A';

      // Phone (always) + Email (if present) beneath
      const tdPhone = document.createElement('td');
      tdPhone.textContent = l.phone || 'â€”';
      if (l.email && typeof l.email === 'string' && l.email.includes('@')) {
        const br = document.createElement('br');
        const em = document.createElement('a');
        em.href = `mailto:${l.email}`;
        em.textContent = l.email;
        em.className = 'link';
        em.style.fontSize = '12px';
        em.style.opacity = '0.9';
        tdPhone.appendChild(br);
        tdPhone.appendChild(em);
      }

      // Website + socials chips below
      const tdWeb = document.createElement('td');
      if (l.website) {
        const a = document.createElement('a');
        a.href = l.website;
        a.target = '_blank';
        a.className = 'link';
        a.textContent = 'Website';
        tdWeb.appendChild(a);
      } else {
        tdWeb.textContent = 'â€”';
      }
      const chips = socialChips(l.socials || {});
      if (chips) tdWeb.appendChild(chips);

      // Rating
      const tdRating = document.createElement('td');
      tdRating.textContent = (l.rating || l.rating === 0) ? `â˜… ${l.rating}` : 'â€”';

      // Reviews
      const tdReviews = document.createElement('td');
      tdReviews.textContent = (l.reviews || l.reviews === 0) ? String(l.reviews) : 'â€”';

      // Address
      const tdAddr = document.createElement('td');
      tdAddr.textContent = l.address || 'â€”';

      tr.appendChild(tdName);
      tr.appendChild(tdPhone);   // âœ… phone always visible
      tr.appendChild(tdWeb);     // website + socials (if any)
      tr.appendChild(tdRating);
      tr.appendChild(tdReviews);
      tr.appendChild(tdAddr);

      tbody.appendChild(tr);
    });

    if (rows.length === 0) {
      tbody.appendChild(h('tr',{}, h('td',{colspan:'6',class:'empty-state'}, 'No leads found')));
    }
  } catch(e) {
    tbody.appendChild(h('tr',{}, h('td',{colspan:'6',class:'empty-state'}, `Error: ${e.message}`)));
  }
}
 
/** ================== Leads view ================== */
/** async function showLeads(batch) {
  const leadsCard = document.getElementById('leadsCard');
  const title = document.getElementById('batchTitle');
  title.textContent = batch.batch_id || '';
  const tbody = document.querySelector('#leadsTable tbody');
  tbody.innerHTML = '';
  leadsCard.style.display = 'block';
  try {
    const url = `${BASE}/webhook/ui/leads?batch_id=${encodeURIComponent(batch.batch_id)}&client_id=${encodeURIComponent(CLIENT_ID)}`;
    const data = await fetchJSON(url);
    const rows = data.data || [];
    rows.forEach(l => {
      tbody.appendChild(h('tr',{},
        h('td',{}, l.name || 'N/A'),
        h('td',{}, l.phone || 'â€”'),
        h('td',{}, l.website ? h('a',{href:l.website,target:'_blank',class:'link'}, 'Website') : 'â€”'),
        h('td',{}, (l.rating || l.rating === 0) ? `â˜… ${l.rating}` : 'â€”'),
        h('td',{}, (l.reviews || l.reviews === 0) ? String(l.reviews) : 'â€”'),
        h('td',{}, l.address || 'â€”')
      ));
    });
    if (rows.length === 0) {
      tbody.appendChild(h('tr',{}, h('td',{colspan:'6',class:'empty-state'}, 'No leads found')));
    }
  } catch(e) {
    tbody.appendChild(h('tr',{}, h('td',{colspan:'6',class:'empty-state'}, `Error: ${e.message}`)));
  }
} */

/** ================== Delete & Re-run ================== */
async function delBatch(b) {
  if (!confirm('Delete this batch and its leads?')) return;
  try {
    const res = await fetch(`${BASE}/webhook/delete-batch`, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ batch_id: b.batch_id, client_id: CLIENT_ID })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    showToast({ title:'Deleted', desc:'Batch removed.', variant:'success', autoCloseMs:2200 });
    loadBatchesAndRender();
  } catch(e) { showToast({ title:'Delete failed', desc:e.message, variant:'error', autoCloseMs:4200 }); }
}

/** ================== Silent Run Watcher ==================
 * - Polls silently (no table render).
 * - Refreshes the table EXACTLY TWICE: first time we detect Processing, and first time we detect Completed.
 * - Toast updates: Queued -> Processing (spinner) -> Completed.
 * - If the toast is closed manually, it will reappear on Completed.
 */
class RunWatcher {
  constructor({ batchId=null, search_term, location, minDateIso }) {
    this.batchId = batchId;
    this.search_term = (search_term||'').trim().toLowerCase();
    this.location = (location||'').trim().toLowerCase();
    this.minDateIso = minDateIso || new Date(0).toISOString();
    this.phase = 'queued'; // queued -> processing -> completed
    this.stopped = false;
    this.toast = null;
    this.didRefreshOnProcessing = false;
    this.didRefreshOnCompleted  = false;
  }
  statusStr(s=''){ const t = s.toLowerCase(); return t.includes('complet') ? 'completed'
                                  : (t.includes('process') || t.includes('active') || t.includes('pending')) ? 'processing'
                                  : 'other'; }
  matchBatch(b){
    if (!b) return false;
    if (this.batchId) return b.batch_id === this.batchId;
    const st = (b.search_term||'').trim().toLowerCase();
    const lc = (b.location||'').trim().toLowerCase();
    const okCrit = (st === this.search_term) && (lc === this.location);
    const okTime = !b.date_created || b.date_created >= this.minDateIso;
    return okCrit && okTime;
  }
  async start({intervalMs=2000, maxMs=240000} = {}) {
    const start = Date.now();
    // Initial toast
    this.toast = showToast({
      title:'Queuedâ€¦', desc:'Watching for Processing and Completion.', variant:'info', loading:true, autoCloseMs:null
    });

    while (!this.stopped && (Date.now()-start) < maxMs) {
      const list = await fetchBatchesOnly(); // SILENT: no table re-render
      // find newest candidate that matches
      let candidate = null;
      for (const b of list) if (this.matchBatch(b)) {
        if (!candidate || (b.date_created||'') > (candidate.date_created||'')) candidate = b;
      }

      if (candidate) {
        const st = this.statusStr(candidate.status||'');

        // -> First time we see Processing
        if (st === 'processing' && this.phase === 'queued') {
          this.phase = 'processing';
          // Update toast (spinner stays)
          if (this.toast) this.toast.update({
            title:'Processingâ€¦', desc:'Scrape is running. Weâ€™ll notify when it completes.', variant:'warn', loading:true, autoCloseMs:null
          });
          // Refresh table ONCE to show the Processing row
          if (!this.didRefreshOnProcessing) {
            await loadBatchesAndRender();
            this.didRefreshOnProcessing = true;
          }
        }

        // -> First time we see Completed
        if (st === 'completed' && this.phase !== 'completed') {
          this.phase = 'completed';
          // Ensure a toast is visible even if user closed it earlier
          if (!this.toast) this.toast = showToast({ title:'Completed ðŸŽ‰', desc:'Batch is ready. You can View the leads now.', variant:'success', loading:false, autoCloseMs:4500 });
          else this.toast.update({ title:'Completed ðŸŽ‰', desc:'Batch is ready. You can View the leads now.', variant:'success', loading:false, autoCloseMs:4500 });
          // Refresh table ONCE to show Completed
          if (!this.didRefreshOnCompleted) {
            await loadBatchesAndRender();
            this.didRefreshOnCompleted = true;
          }
          return true;
        }
      }
      await new Promise(r=>setTimeout(r, intervalMs));
    }

    // Timeout fallback copy
    if (this.toast) this.toast.update({
      title:'Still queued', desc:'You can click Refresh any time. Weâ€™ll keep watching next run.', variant:'warn', loading:false, autoCloseMs:4000
    });
    return false;
  }
  stop(){ this.stopped = true; /* leave toast as-is */ }
}

/** ================== Submit / Re-run ================== */
document.getElementById('scrapeForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const search_term = document.getElementById('search_term').value.trim();
  const location = document.getElementById('location').value.trim();
  if (!search_term || !location) return;

  const minDateIso = new Date().toISOString();
  const r = await postBestEffort(`${BASE}/webhook/scrape-leads`, { search_term, location, client_id: CLIENT_ID });
  const batchId = (r && r.body && r.body.batch_id) ? r.body.batch_id : null;

  // Start silent watcher (no table spam; exactly two refreshes)
  const watcher = new RunWatcher({ batchId, search_term, location, minDateIso });
  watcher.start(); // runs in background
});

async function rerun(b) {
  if (!confirm('Re-run scraping for this batch?')) return;
  const minDateIso = new Date().toISOString();
  const r = await postBestEffort(`${BASE}/webhook/rerun-scraping`, { record_id: b.record_id, client_id: CLIENT_ID });
  const batchId = (r && r.body && r.body.batch_id) ? r.body.batch_id : null;

  const watcher = new RunWatcher({ batchId, search_term: b.search_term, location: b.location, minDateIso });
  watcher.start();
}

/** ================== Manual refresh button + initial render ================== */
document.getElementById('refreshBtn').addEventListener('click', loadBatchesAndRender);
loadBatchesAndRender();
</script>
</body>
</html>
