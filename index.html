<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lead Scraper & Manager</title>
<style>
  * { box-sizing: border-box; }
  :root{
    --accent:#7e3ace; --accent-2:#9c5df0; --accent-3:#b892ff;
    --bg:#f7f5fb; --card:#fff; --text:#1f2330; --muted:#6b7280; --border:#e5e7eb;
    --ok:#16a34a; --warn:#92400e; --err:#b91c1c;
  }
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif; background:var(--bg); color:var(--text); margin:0; padding:12px; font-size:14px; line-height:1.4; }
  .wrap { max-width:100%; margin:0 auto; display:flex; flex-direction:column; gap:16px; }
  .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px; box-shadow:0 1px 3px rgba(0,0,0,0.06); }
  h1 { font-size:20px; margin:0 0 8px 0; font-weight:700; line-height:1.2; }
  .subtitle { color:var(--muted); margin-bottom:16px; font-size:14px; }
  label { display:block; font-size:13px; color:var(--muted); margin-bottom:6px; font-weight:500; }
  input[type=text]{ width:100%; padding:12px; border:1.8px solid var(--border); border-radius:10px; font-size:16px; background:#fff; -webkit-appearance:none; }
  input[type=text]:focus{ outline:none; border-color:var(--accent); box-shadow: 0 0 0 3px rgba(126,58,206,.12); }
  .form-group{ margin-bottom:16px; }
  .button-row{ display:flex; gap:8px; flex-wrap:wrap; }
  .btn{ flex:1; min-width:120px; padding:12px 16px; border:2px solid var(--accent); background:var(--accent); color:#fff; border-radius:10px; cursor:pointer; font-size:14px; font-weight:700; text-align:center; transition:all .16s; }
  .btn:active{ transform:translateY(1px); }
  .btn.secondary{ background:#fff; color:var(--accent); }
  .btn.small{ flex:none; min-width:auto; padding:6px 12px; font-size:12px; font-weight:600; }
  .table-wrapper{ overflow-x:auto; -webkit-overflow-scrolling:touch; margin:-16px; padding:16px; }
  table{ width:100%; min-width:600px; border-collapse:collapse; font-size:13px; }
  th,td{ padding:12px 8px; text-align:left; border-bottom:1px solid var(--border); vertical-align:top; }
  th{ background:var(--bg); font-weight:700; color:var(--text); position:sticky; top:0; }
  .batch-id{ font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; color:var(--muted); }
  .badge{ display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:700; background:var(--bg); border:1px solid var(--border); letter-spacing:.2px; }
  .badge.completed{ background:#dcfce7; color:#166534; border-color:#bbf7d0; }
  /* PROCESSING stays yellow */
  .badge.processing{ background:#fef3c7; color:#92400e; border-color:#fde68a; }
  .actions{ display:flex; gap:4px; flex-wrap:wrap; }
  .link{ color:var(--accent); text-decoration:none; font-weight:600; }
  .link:hover{ text-decoration:underline; }
  .empty-state{ text-align:center; padding:32px 16px; color:var(--muted); }

  /* Enhanced contact cell styles */
  .contact-cell{ 
    display:flex; 
    flex-direction:column; 
    gap:4px; 
    min-width:140px;
  }
  .phone-number{ 
    font-weight:600; 
    color:var(--text); 
  }
  .email-address{ 
    font-size:12px; 
    color:var(--muted); 
    font-style:italic;
  }

  /* Social links styles */
  .socials-cell{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
    min-width:120px;
  }
  .social-link{
    display:inline-flex;
    align-items:center;
    gap:4px;
    padding:2px 6px;
    background:var(--bg);
    border:1px solid var(--border);
    border-radius:6px;
    text-decoration:none;
    font-size:11px;
    font-weight:600;
    color:var(--text);
    transition:all .15s;
  }
  .social-link:hover{
    background:var(--accent);
    color:white;
    border-color:var(--accent);
  }
  .social-icon{
    width:12px;
    height:12px;
    border-radius:2px;
  }
  .social-linkedin{ background:#0077b5; }
  .social-facebook{ background:#1877f2; }
  .social-twitter{ background:#1da1f2; }
  .social-instagram{ background:#e4405f; }

  @media (min-width:768px){
    body{ padding:24px; font-size:14px; }
    .wrap{ max-width:1200px; margin:0 auto; gap:24px; }
    .card{ padding:24px; }
    h1{ font-size:24px; margin-bottom:12px; }
    .subtitle{ font-size:16px; margin-bottom:24px; }
    input[type=text]{ font-size:14px; padding:10px 12px; }
    .form-grid{ display:grid; grid-template-columns:1fr 1fr; gap:16px; }
    .btn{ flex:none; min-width:140px; }
    table{ min-width:800px; font-size:14px; }
    th,td{ padding:12px; }
  }

   /* Toast container */
  .toast-wrap{
    position:fixed; right:16px; top:16px;
    display:flex; flex-direction:column; gap:10px; z-index:9999;
  }

  /* Toast box */
  .toast{
    min-width:260px; max-width:360px;
    background:#fff; border:1px solid #e5e7eb; border-left-width:6px;
    border-radius:12px; padding:12px 14px;
    box-shadow:0 10px 26px rgba(126,58,206,.18);
    display:flex;                 
    flex-direction:column;        
    gap:6px;                      
  }

  /* color accents */
  .toast.info{ border-left-color:#7e3ace }
  .toast.success{ border-left-color:#16a34a }
  .toast.warn{ border-left-color:#f59e0b }
  .toast.error{ border-left-color:#ef4444 }

  /* first row: title + close */
  .toast .head{
    display:flex; justify-content:space-between; align-items:center;
  }
  .toast .title{
    font-weight:700; font-size:14px; color:#1f2330;
    display:flex; align-items:center; gap:8px;
  }
  .toast .x{
    border:none; background:transparent; font-size:16px; cursor:pointer; opacity:.6;
  }
  .toast .x:hover{ opacity:1 }

  /* second row: subtext */
  .toast .desc{
    font-size:13px; color:#4b5563; line-height:1.35;
    margin-top:2px;               
  }

  /* spinner */
  .spin{
    width:14px; height:14px; display:inline-block; border-radius:999px;
    border:2px solid #d1d5db; border-top-color:#7e3ace; animation:sp .8s linear infinite;
  }
  @keyframes sp{ to{ transform:rotate(360deg); } }
 
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Lead Scraper</h1>
    <p class="subtitle">Submit a new search, then manage recent batches below.</p>
    <form id="scrapeForm">
      <div class="form-grid">
        <div class="form-group">
          <label>Business Type</label>
          <input type="text" id="search_term" placeholder="e.g., plumber" required />
        </div>
        <div class="form-group">
          <label>Location</label>
          <input type="text" id="location" placeholder="e.g., Lekki, Lagos" required />
        </div>
      </div>
      <div class="button-row">
        <button class="btn" type="submit" id="scrapeBtn">Scrape 5 Leads</button>
        <button class="btn secondary" type="button" id="refreshBtn">Refresh</button>
      </div>
    </form>
  </div>

  <div class="card">
    <h1>Recent Batches</h1>
    <div class="table-wrapper">
      <table id="batchesTable">
        <thead>
          <tr>
            <th>Batch</th>
            <th>Criteria</th>
            <th>Date</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="card" id="leadsCard" style="display:none;">
    <h1>Leads in Batch</h1>
    <p class="subtitle" id="batchTitle"></p>
    <div class="table-wrapper">
      <table id="leadsTable">
        <thead>
          <tr>
            <th>Name</th>
            <th>Contact</th>
            <th>Website</th>
            <th>Rating</th>
            <th>Reviews</th>
            <th>Address</th>
            <th id="socialsHeader" style="display:none;">Socials</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<!-- Toast container -->
<div class="toast-wrap" id="toastWrap" aria-live="polite" aria-atomic="true"></div>

<script>
/** ================== CONFIG ================== */
const BASE = 'https://n8n.autocraft.site';

/** ================== CLIENT ID (per-browser isolation) ================== */
function getClientId(){
  let id = localStorage.getItem('client_id');
  if (!id) {
    id = (crypto && crypto.randomUUID) ? crypto.randomUUID()
      : 'cid_' + Math.random().toString(36).slice(2) + Date.now();
    localStorage.setItem('client_id', id);
  }
  return id;
}
const CLIENT_ID = getClientId();

/** ================== Tiny DOM helper ================== */
const h = (tag, attrs={}, ...kids) => {
  const el = document.createElement(tag);
  Object.entries(attrs||{}).forEach(([k,v])=>{
    if (k === 'class') el.className = v;
    else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.slice(2), v);
    else el.setAttribute(k,v);
  });
  kids.forEach(k => {
    if (k == null) return;
    if (typeof k === 'string') el.appendChild(document.createTextNode(k));
    else el.appendChild(k);
  });
  return el;
};

/** ================== Fetch helpers with 304 prevention ================== */
async function fetchJSON(url, opts={}) {
  // Add cache-busting and no-cache headers
  const finalUrl = url.includes('?') ? `${url}&_t=${Date.now()}` : `${url}?_t=${Date.now()}`;
  const res = await fetch(finalUrl, {
    ...opts,
    headers: {
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0',
      ...opts.headers
    }
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  try { return await res.json(); } catch { return {}; }
}

async function postBestEffort(url, payload) {
  try {
    const res = await fetch(url, {
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Cache-Control':'no-store',
        'Pragma': 'no-cache'
      },
      body: JSON.stringify(payload),
    });
    let body=null; try { body = await res.json(); } catch {}
    return { ok: res.ok, status: res.status, body };
  } catch (e) {
    return { ok:false, status:0, body:null, error:e.message };
  }
}

/** ================== Toast (top-right, spinner, purple accent) ================== */
(function ensureToastStyles(){
  if (document.getElementById('toast-styles')) return;
  const css = `
  .toast-wrap{position:fixed;right:16px;top:16px;display:flex;flex-direction:column;gap:8px;z-index:9999}
  .toast{min-width:260px;max-width:360px;background:#fff;border:1px solid #e5e7eb;border-left-width:6px;border-radius:10px;
         box-shadow:0 10px 25px rgba(0,0,0,.08);padding:12px 12px 12px 10px;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  .toast .head{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .toast .title{font-weight:700;font-size:14px;color:#1f2330;display:flex;align-items:center;gap:8px}
  .toast .x{border:none;background:transparent;font-size:16px;cursor:pointer;opacity:.6}
  .toast .x:hover{opacity:1}
  .toast .desc{font-size:13px;color:#4b5563;line-height:1.35}
  .toast.info{border-left-color:#7e3ace}
  .toast.success{border-left-color:#16a34a}
  .toast.warn{border-left-color:#f59e0b}
  .toast.error{border-left-color:#ef4444}
  /* spinner */
  .spin{width:14px;height:14px;display:inline-block;border-radius:999px;border:2px solid #d1d5db;border-top-color:#7e3ace;animation:sp .8s linear infinite}
  @keyframes sp{to{transform:rotate(360deg)}}`;
  const s = document.createElement('style'); s.id='toast-styles'; s.textContent = css; document.head.appendChild(s);
})();

function getToastHost(){
  let host = document.querySelector('.toast-wrap');
  if (!host){ host = document.createElement('div'); host.className='toast-wrap'; document.body.appendChild(host); }
  return host;
}

function showToast({title, desc, variant='info', loading=false, autoCloseMs=null}){
  const host = getToastHost();
  const el = document.createElement('div');
  el.className = `toast ${variant}`;
  el.innerHTML = `
    <div class="head">
      <div class="title"></div>
      <button class="x" aria-label="Close">&times;</button>
    </div>
    <div class="desc"></div>`;
  const ttl = el.querySelector('.title');
  if (loading) {
    const sp = document.createElement('span'); sp.className='spin';
    ttl.appendChild(sp);
  }
  const setTitle = (t)=>{ ttl.childNodes.forEach(n=>{ if(n.nodeType===3) ttl.removeChild(n); }); ttl.appendChild(document.createTextNode(t)); if (loading) ttl.insertBefore(ttl.querySelector('.spin'), ttl.firstChild); };
  setTitle(title || '');
  el.querySelector('.desc').textContent = desc || '';
  let timer = null;
  function close(){ if (timer) clearTimeout(timer); el.remove(); }
  el.querySelector('.x').addEventListener('click', close);
  host.appendChild(el);
  return {
    el, close,
    update({title, desc, variant, loading:ld, autoCloseMs}){
      if (title != null) setTitle(title);
      if (desc  != null) el.querySelector('.desc').textContent = desc;
      if (variant){ el.className = `toast ${variant}`; }
      if (ld != null){
        const has = !!el.querySelector('.spin');
        if (ld && !has){ const sp = document.createElement('span'); sp.className='spin'; ttl.insertBefore(sp, ttl.firstChild); }
        if (!ld && has){ el.querySelector('.spin').remove(); }
      }
      if (autoCloseMs != null){
        if (timer) clearTimeout(timer);
        if (autoCloseMs) timer = setTimeout(()=>this.close(), autoCloseMs);
      }
    }
  };
}

/** ================== Helper functions for contact and socials ================== */
function createSocialLink(platform, url) {
  const platformNames = {
    linkedin: 'LinkedIn',
    facebook: 'Facebook', 
    twitter: 'Twitter',
    instagram: 'Instagram'
  };
  
  const link = h('a', {
    href: url,
    target: '_blank',
    class: 'social-link'
  },
    h('span', {class: `social-icon social-${platform}`}),
    platformNames[platform] || platform
  );
  
  return link;
}

function createContactCell(phone, email) {
  const contactDiv = h('div', {class: 'contact-cell'});
  
  if (phone && phone !== '—') {
    contactDiv.appendChild(h('div', {class: 'phone-number'}, phone));
  }
  
  if (email && email !== '') {
    contactDiv.appendChild(h('div', {class: 'email-address'}, email));
  }
  
  if (!phone || phone === '—') {
    contactDiv.appendChild(h('div', {class: 'phone-number'}, '—'));
  }
  
  return contactDiv;
}

function createSocialsCell(socials) {
  const socialsDiv = h('div', {class: 'socials-cell'});
  let hasAnySocials = false;
  
  Object.entries(socials || {}).forEach(([platform, url]) => {
    if (url && url !== '') {
      socialsDiv.appendChild(createSocialLink(platform, url));
      hasAnySocials = true;
    }
  });
  
  if (!hasAnySocials) {
    socialsDiv.appendChild(h('span', {style: 'color: var(--muted); font-size: 12px;'}, '—'));
  }
  
  return socialsDiv;
}

/** ================== Batches table ================== */
/* Render table (used for manual refresh + the two controlled refreshes) */
async function loadBatchesAndRender() {
  const tbody = document.querySelector('#batchesTable tbody');
  tbody.innerHTML = '';
  try {
    const data = await fetchJSON(`${BASE}/webhook/ui/batches?client_id=${encodeURIComponent(CLIENT_ID)}`);
    const list = data.data || [];
    list.forEach(b => {
      const actions = h('div', {class:'actions'},
        h('button', {class:'btn small secondary', onclick:()=>showLeads(b)}, 'View'),
        h('button', {class:'btn small secondary', onclick:()=>rerun(b)}, 'Re-run'),
        h('button', {class:'btn small', onclick:()=>delBatch(b)}, 'Delete'),
      );
      const criteria = `${b.search_term} – ${b.location}`;
      const shortId = b.batch_id && b.batch_id.length > 20 ? b.batch_id.substring(0, 20) + '…' : (b.batch_id || '—');
      const statusRaw = (b.status || '').toLowerCase();
      const statusClass = statusRaw.includes('complet') ? 'completed'
                        : (statusRaw.includes('process') || statusRaw.includes('active') || statusRaw.includes('pending')) ? 'processing'
                        : '';
      tbody.appendChild(h('tr', {},
        h('td', {}, h('span', {class:'batch-id'}, shortId)),
        h('td', {}, criteria),
        h('td', {}, b.date_created ? new Date(b.date_created).toLocaleString() : '—'),
        h('td', {}, h('span', {class:`badge ${statusClass}`}, b.status || '—')),
        h('td', {}, actions),
      ));
    });
    if (list.length === 0) {
      tbody.appendChild(h('tr',{}, h('td',{colspan:'5', class:'empty-state'}, 'No batches found')));
    }
    return list;
  } catch(e) {
    tbody.appendChild(h('tr',{}, h('td',{colspan:'5', class:'empty-state'}, `Error: ${e.message}`)));
    return [];
  }
}

/* Fetch batches silently without re-rendering table */
async function fetchBatchesOnly() {
  try {
    const data = await fetchJSON(`${BASE}/webhook/ui/batches?client_id=${encodeURIComponent(CLIENT_ID)}`);
    return data?.data || [];
  } catch { return []; }
}

/** ================== Leads view ================== */
async function showLeads(batch) {
  const leadsCard = document.getElementById('leadsCard');
  const title = document.getElementById('batchTitle');
  const socialsHeader = document.getElementById('socialsHeader');
  title.textContent = batch.batch_id || '';
  const tbody = document.querySelector('#leadsTable tbody');
  tbody.innerHTML = '';
  leadsCard.style.display = 'block';
  
  // Hide socials column initially
  socialsHeader.style.display = 'none';
  
  try {
    const url = `${BASE}/webhook/ui/leads?batch_id=${encodeURIComponent(batch.batch_id)}&client_id=${encodeURIComponent(CLIENT_ID)}`;
    const data = await fetchJSON(url);
    const rows = data.data || [];
    
    // Check if any lead has socials to determine if we should show the column
    let hasAnySocials = rows.some(l => {
      const socials = l.socials || {};
      return Object.values(socials).some(url => url && url !== '');
    });
    
    if (hasAnySocials) {
      socialsHeader.style.display = 'table-cell';
    }
    
    rows.forEach(l => {
      const row = h('tr', {},
        h('td', {}, l.name || 'N/A'),
        h('td', {}, createContactCell(l.phone, l.email)),
        h('td', {}, l.website ? h('a', {href: l.website, target: '_blank', class: 'link'}, 'Website') : '—'),
        h('td', {}, (l.rating || l.rating === 0) ? `★ ${l.rating}` : '—'),
        h('td', {}, (l.reviews || l.reviews === 0) ? String(l.reviews) : '—'),
        h('td', {}, l.address || '—')
      );
      
      // Only add socials cell if there are socials in this batch
      if (hasAnySocials) {
        row.appendChild(h('td', {}, createSocialsCell(l.socials)));
      }
      
      tbody.appendChild(row);
    });
    
    if (rows.length === 0) {
      const colspan = hasAnySocials ? '7' : '6';
      tbody.appendChild(h('tr', {}, h('td', {colspan: colspan, class: 'empty-state'}, 'No leads found')));
    }
  } catch(e) {
    const colspan = socialsHeader.style.display === 'table-cell' ? '7' : '6';
    tbody.appendChild(h('tr', {}, h('td', {colspan: colspan, class: 'empty-state'}, `Error: ${e.message}`)));
  }
}

/** ================== Delete & Re-run with auto-close toasts ================== */
async function delBatch(b) {
  if (!confirm('Delete this batch and its leads?')) return;
  try {
    const res = await fetch(`${BASE}/webhook/delete-batch`, {
      method:'POST', 
      headers:{
        'Content-Type':'application/json',
        'Cache-Control':'no-store'
      },
      body: JSON.stringify({ batch_id: b.batch_id, client_id: CLIENT_ID })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    showToast({ title:'Deleted', desc:'Batch removed successfully.', variant:'success', autoCloseMs:3000 });
    loadBatchesAndRender();
  } catch(e) { 
    showToast({ title:'Delete failed', desc:e.message, variant:'error', autoCloseMs:5000 }); 
  }
}

/** ================== Silent Run Watcher ==================
 * - Polls silently (no table render).
 * - Refreshes the table EXACTLY TWICE: first time we detect Processing, and first time we detect Completed.
 * - Toast updates: Queued -> Processing (spinner) -> Completed.
 * - If the toast is closed manually, it will reappear on Completed.
 */
class RunWatcher {
  constructor({ batchId=null, search_term, location, minDateIso }) {
    this.batchId = batchId;
    this.search_term = (search_term||'').trim().toLowerCase();
    this.location = (location||'').trim().toLowerCase();
    this.minDateIso = minDateIso || new Date(0).toISOString();
    this.phase = 'queued'; // queued -> processing -> completed
    this.stopped = false;
    this.toast = null;
    this.didRefreshOnProcessing = false;
    this.didRefreshOnCompleted  = false;
  }
  statusStr(s=''){ const t = s.toLowerCase(); return t.includes('complet') ? 'completed'
                                  : (t.includes('process') || t.includes('active') || t.includes('pending')) ? 'processing'
                                  : 'other'; }
  matchBatch(b){
    if (!b) return false;
    if (this.batchId) return b.batch_id === this.batchId;
    const st = (b.search_term||'').trim().toLowerCase();
    const lc = (b.location||'').trim().toLowerCase();
    const okCrit = (st === this.search_term) && (lc === this.location);
    const okTime = !b.date_created || b.date_created >= this.minDateIso;
    return okCrit && okTime;
  }
  async start({intervalMs=2000, maxMs=240000} = {}) {
    const start = Date.now();
    // Initial toast
    this.toast = showToast({
      title:'Queued…', desc:'Watching for Processing and Completion.', variant:'info', loading:true, autoCloseMs:null
    });

    while (!this.stopped && (Date.now()-start) < maxMs) {
      const list = await fetchBatchesOnly(); // SILENT: no table re-render
      // find newest candidate that matches
      let candidate = null;
      for (const b of list) if (this.matchBatch(b)) {
        if (!candidate || (b.date_created||'') > (candidate.date_created||'')) candidate = b;
      }

      if (candidate) {
        const st = this.statusStr(candidate.status||'');

        // -> First time we see Processing
        if (st === 'processing' && this.phase === 'queued') {
          this.phase = 'processing';
          // Update toast (spinner stays)
          if (this.toast) this.toast.update({
            title:'Processing…', desc:'Scrape is running. We'll notify when it completes.', variant:'warn', loading:true, autoCloseMs:null
          });
          // Refresh table ONCE to show the Processing row
          if (!this.didRefreshOnProcessing) {
            await loadBatchesAndRender();
            this.didRefreshOnProcessing = true;
          }
        }

        // -> First time we see Completed
        if (st === 'completed' && this.phase !== 'completed') {
          this.phase = 'completed';
          // Ensure a toast is visible even if user closed it earlier
          if (!this.toast) this.toast = showToast({ title:'Completed 🎉', desc:'Batch is ready. You can View the leads now.', variant:'success', loading:false, autoCloseMs:4500 });
          else this.toast.update({ title:'Completed 🎉', desc:'Batch is ready. You can View the leads now.', variant:'success', loading:false, autoCloseMs:4500 });
          // Refresh table ONCE to show Completed
          if (!this.didRefreshOnCompleted) {
            await loadBatchesAndRender();
            this.didRefreshOnCompleted = true;
          }
          return true;
        }
      }
      await new Promise(r=>setTimeout(r, intervalMs));
    }

    // Timeout fallback copy
    if (this.toast) this.toast.update({
      title:'Still queued', desc:'You can click Refresh any time. We'll keep watching next run.', variant:'warn', loading:false, autoCloseMs:4000
    });
    return false;
  }
  stop(){ this.stopped = true; /* leave toast as-is */ }
}

/** ================== Submit / Re-run ================== */
document.getElementById('scrapeForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const search_term = document.getElementById('search_term').value.trim();
  const location = document.getElementById('location').value.trim();
  if (!search_term || !location) return;

  const minDateIso = new Date().toISOString();
  const r = await postBestEffort(`${BASE}/webhook/scrape-leads`, { search_term, location, client_id: CLIENT_ID });
  const batchId = (r && r.body && r.body.batch_id) ? r.body.batch_id : null;

  // Start silent watcher (no table spam; exactly two refreshes)
  const watcher = new RunWatcher({ batchId, search_term, location, minDateIso });
  watcher.start(); // runs in background
});

async function rerun(b) {
  if (!confirm('Re-run scraping for this batch?')) return;
  const minDateIso = new Date().toISOString();
  const r = await postBestEffort(`${BASE}/webhook/rerun-scraping`, { record_id: b.record_id, client_id: CLIENT_ID });
  const batchId = (r && r.body && r.body.batch_id) ? r.body.batch_id : null;

  const watcher = new RunWatcher({ batchId, search_term: b.search_term, location: b.location, minDateIso });
  watcher.start();
}

/** ================== Manual refresh button + initial render ================== */
document.getElementById('refreshBtn').addEventListener('click', loadBatchesAndRender);
loadBatchesAndRender();
</script>
</body>
</html>
