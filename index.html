<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lead Scraper & Manager</title>
<style>
  * { box-sizing: border-box; }
  :root{
    --accent:#7e3ace; --accent-2:#9c5df0; --accent-3:#b892ff;
    --bg:#f7f5fb; --card:#fff; --text:#1f2330; --muted:#6b7280; --border:#e5e7eb;
    --ok:#16a34a; --warn:#92400e; --err:#b91c1c;
  }
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif; background:var(--bg); color:var(--text); margin:0; padding:12px; font-size:14px; line-height:1.4; }
  .wrap { max-width:100%; margin:0 auto; display:flex; flex-direction:column; gap:16px; }
  .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px; box-shadow:0 1px 3px rgba(0,0,0,0.06); }
  h1 { font-size:20px; margin:0 0 8px 0; font-weight:700; line-height:1.2; }
  .subtitle { color:var(--muted); margin-bottom:16px; font-size:14px; }
  label { display:block; font-size:13px; color:var(--muted); margin-bottom:6px; font-weight:500; }
  input[type=text]{ width:100%; padding:12px; border:1.8px solid var(--border); border-radius:10px; font-size:16px; background:#fff; -webkit-appearance:none; }
  input[type=text]:focus{ outline:none; border-color:var(--accent); box-shadow: 0 0 0 3px rgba(126,58,206,.12); }
  .form-group{ margin-bottom:16px; }
  .button-row{ display:flex; gap:8px; flex-wrap:wrap; }
  .btn{ flex:1; min-width:120px; padding:12px 16px; border:2px solid var(--accent); background:var(--accent); color:#fff; border-radius:10px; cursor:pointer; font-size:14px; font-weight:700; text-align:center; transition:all .16s; }
  .btn:active{ transform:translateY(1px); }
  .btn.secondary{ background:#fff; color:var(--accent); }
  .btn.small{ flex:none; min-width:auto; padding:6px 12px; font-size:12px; font-weight:600; }
  .table-wrapper{ overflow-x:auto; -webkit-overflow-scrolling:touch; margin:-16px; padding:16px; }
  table{ width:100%; min-width:600px; border-collapse:collapse; font-size:13px; }
  th,td{ padding:12px 8px; text-align:left; border-bottom:1px solid var(--border); vertical-align:top; }
  th{ background:var(--bg); font-weight:700; color:var(--text); position:sticky; top:0; }
  .batch-id{ font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; color:var(--muted); }
  .badge{ display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:700; background:var(--bg); border:1px solid var(--border); letter-spacing:.2px; }
  .badge.completed{ background:#dcfce7; color:#166534; border-color:#bbf7d0; }
  /* PROCESSING stays yellow */
  .badge.processing{ background:#fef3c7; color:#92400e; border-color:#fde68a; }
  .actions{ display:flex; gap:4px; flex-wrap:wrap; }
  .link{ color:var(--accent); text-decoration:none; font-weight:600; }
  .link:hover{ text-decoration:underline; }
  .empty-state{ text-align:center; padding:32px 16px; color:var(--muted); }

  @media (min-width:768px){
    body{ padding:24px; font-size:14px; }
    .wrap{ max-width:1200px; margin:0 auto; gap:24px; }
    .card{ padding:24px; }
    h1{ font-size:24px; margin-bottom:12px; }
    .subtitle{ font-size:16px; margin-bottom:24px; }
    input[type=text]{ font-size:14px; padding:10px 12px; }
    .form-grid{ display:grid; grid-template-columns:1fr 1fr; gap:16px; }
    .btn{ flex:none; min-width:140px; }
    table{ min-width:700px; font-size:14px; }
    th,td{ padding:12px; }
  }

  /* Purple Toasts (top-right) */
  .toast-wrap{
    position: fixed; top: 16px; right: 16px; width: min(360px, 92vw);
    display: flex; flex-direction: column; gap: 10px; z-index: 9999;
  }
  .toast{
    background: #fff; border: 1px solid var(--border); border-left-width: 6px;
    border-radius: 12px; padding: 12px 14px; box-shadow: 0 10px 26px rgba(126,58,206,.18);
    display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: start;
    animation: slideIn .18s ease-out;
  }
  .toast.info{ border-left-color: var(--accent-2); }
  .toast.success{ border-left-color: var(--ok); }
  .toast.warn{ border-left-color: #a855f7; }
  .toast.error{ border-left-color: var(--err); }
  .toast-title{ font-weight: 800; margin: 0; font-size: 14px; color: var(--text);}
  .toast-desc{ margin: 0; color: var(--muted); font-size: 13px; grid-column: 1 / span 2; }
  .toast .close{
    border: none; background: transparent; font-size: 18px; line-height: 1;
    color: var(--accent-2); cursor: pointer; padding: 0 4px;
  }
  .toast .timerbar{
    height: 3px; background: #efe7ff; border-radius: 2px; overflow: hidden; grid-column: 1 / span 2;
  }
  .toast .timerbar > i{
    display:block; height:100%; width: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent-2), var(--accent-3));
    transform-origin: left; animation: shrink linear forwards;
  }
  @keyframes slideIn { from{ transform: translateY(-6px); opacity: 0; } to{ transform: translateY(0); opacity: 1; } }
  @keyframes shrink { from{ transform: scaleX(1); } to{ transform: scaleX(0); } }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Lead Scraper</h1>
    <p class="subtitle">Submit a new search, then manage recent batches below.</p>
    <form id="scrapeForm">
      <div class="form-grid">
        <div class="form-group">
          <label>Business Type</label>
          <input type="text" id="search_term" placeholder="e.g., plumber" required />
        </div>
        <div class="form-group">
          <label>Location</label>
          <input type="text" id="location" placeholder="e.g., Lekki, Lagos" required />
        </div>
      </div>
      <div class="button-row">
        <button class="btn" type="submit" id="scrapeBtn">Scrape 5 Leads</button>
        <button class="btn secondary" type="button" id="refreshBtn">Refresh</button>
      </div>
    </form>
  </div>

  <div class="card">
    <h1>Recent Batches</h1>
    <div class="table-wrapper">
      <table id="batchesTable">
        <thead>
          <tr>
            <th>Batch</th>
            <th>Criteria</th>
            <th>Date</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="card" id="leadsCard" style="display:none;">
    <h1>Leads in Batch</h1>
    <p class="subtitle" id="batchTitle"></p>
    <div class="table-wrapper">
      <table id="leadsTable">
        <thead>
          <tr>
            <th>Name</th>
            <th>Phone</th>
            <th>Website</th>
            <th>Rating</th>
            <th>Reviews</th>
            <th>Address</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<!-- Toast container -->
<div class="toast-wrap" id="toastWrap" aria-live="polite" aria-atomic="true"></div>

<script>
/** Base URL for your n8n instance */
const BASE = 'https://n8n.autocraft.site';

/** Generate or read a persistent per-browser client_id */
function getClientId(){
  let id = localStorage.getItem('client_id');
  if (!id) {
    id = (crypto && crypto.randomUUID) ? crypto.randomUUID()
      : 'cid_' + Math.random().toString(36).slice(2) + Date.now();
    localStorage.setItem('client_id', id);
  }
  return id;
}
const CLIENT_ID = getClientId();

/** tiny DOM helper */
const h = (tag, attrs={}, ...kids) => {
  const el = document.createElement(tag);
  Object.entries(attrs||{}).forEach(([k,v])=>{
    if (k === 'class') el.className = v;
    else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.slice(2), v);
    else el.setAttribute(k,v);
  });
  kids.forEach(k => {
    if (k == null) return;
    if (typeof k === 'string') el.appendChild(document.createTextNode(k));
    else el.appendChild(k);
  });
  return el;
};

/** fetch wrapper (no API key) */
async function fetchJSON(url, opts={}) {
  const res = await fetch(url, opts);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  try { return await res.json(); } catch { return {}; }
}

/** Toast system (purple) */
const toastWrap = document.getElementById('toastWrap');
let _toastIdx = 0;
function showToast({title='Notice', desc='', variant='info', duration=3500, sticky=false}) {
  const id = `t_${++_toastIdx}`;
  const closeBtn = h('button', {class:'close', 'aria-label':'Close', onclick:()=>removeToast(id)}, 'Ã—');
  const timerBar = h('div', {class:'timerbar'}, h('i', {style: !sticky ? `animation-duration:${duration}ms` : 'display:none'}));
  const node = h('div', {class:`toast ${variant}`, id},
    h('p', {class:'toast-title'}, title),
    closeBtn,
    h('p', {class:'toast-desc'}, desc),
    timerBar
  );
  toastWrap.appendChild(node);
  if (!sticky) setTimeout(()=> removeToast(id), duration);
  return {
    id,
    update: ({title:title2, desc:desc2, variant:var2='success', autoCloseMs=2500}={}) => {
      if (title2) node.querySelector('.toast-title').textContent = title2;
      if (desc2 !== undefined) node.querySelector('.toast-desc').textContent = desc2;
      node.className = `toast ${var2}`;
      const bar = node.querySelector('.timerbar > i');
      bar.style.display = 'block';
      bar.style.animation = 'none';
      void bar.offsetWidth; // restart animation
      bar.style.animation = `shrink ${autoCloseMs}ms linear forwards`;
      setTimeout(()=> removeToast(id), autoCloseMs);
    }
  };
}
function removeToast(id){
  const el = document.getElementById(id);
  if (el && el.parentNode) el.parentNode.removeChild(el);
}

/** Helpers */
function criteriaKey(search_term, location) {
  return `${(search_term||'').trim().toLowerCase()}::${(location||'').trim().toLowerCase()}`;
}

/** Render table and also return the list for logic */
async function loadBatchesAndReturn() {
  const tbody = document.querySelector('#batchesTable tbody');
  tbody.innerHTML = '';
  try {
    const data = await fetchJSON(`${BASE}/webhook/ui/batches?client_id=${encodeURIComponent(CLIENT_ID)}`);
    const list = data.data || [];

    list.forEach(b => {
      const actions = h('div', {class:'actions'},
        h('button', {class:'btn small secondary', onclick:()=>showLeads(b)}, 'View'),
        h('button', {class:'btn small secondary', onclick:()=>rerun(b)}, 'Re-run'),
        h('button', {class:'btn small', onclick:()=>delBatch(b)}, 'Delete'),
      );

      const criteria = `${b.search_term} â€“ ${b.location}`;
      const shortId = b.batch_id && b.batch_id.length > 20 ? b.batch_id.substring(0, 20) + 'â€¦' : (b.batch_id || 'â€”');

      const statusRaw = (b.status || '').toLowerCase();
      const statusClass = statusRaw.includes('complet') ? 'completed'
                        : (statusRaw.includes('active') || statusRaw.includes('process')) ? 'processing'
                        : '';

      tbody.appendChild(h('tr', {},
        h('td', {}, h('span', {class:'batch-id'}, shortId)),
        h('td', {}, criteria),
        h('td', {}, b.date_created ? new Date(b.date_created).toLocaleString() : 'â€”'),
        h('td', {}, h('span', {class:`badge ${statusClass}`}, b.status || 'â€”')),
        h('td', {}, actions),
      ));
    });

    if (list.length === 0) {
      tbody.appendChild(h('tr',{}, h('td',{colspan:'5', class:'empty-state'}, 'No batches found')));
    }
    return list;
  } catch(e) {
    const tbody = document.querySelector('#batchesTable tbody');
    tbody.innerHTML = '';
    tbody.appendChild(h('tr',{}, h('td',{colspan:'5', class:'empty-state'}, `Error: ${e.message}`)));
    return [];
  }
}

/** Find newest batch for a (search_term, location) */
function findNewestForCriteria(list, search_term, location) {
  const key = criteriaKey(search_term, location);
  let newest = null;
  for (const b of list) {
    const k = criteriaKey(b.search_term, b.location);
    if (k !== key) continue;
    if (!newest || (b.date_created||'') > (newest.date_created||'')) newest = b;
  }
  return newest;
}

/** Stage 1: Poll until the new batch appears in "Processing" (active/process).
 *  Returns true if found (and refreshes the table each loop).
 */
async function pollUntilProcessing({search_term, location, minDateIso=null, timeoutMs=45000, intervalMs=2000}) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    const list = await loadBatchesAndReturn();
    const newest = findNewestForCriteria(list, search_term, location);
    if (newest) {
      const dc = newest.date_created || '';
      const isNew = !minDateIso || (dc && dc > minDateIso);
      const status = (newest.status || '').toLowerCase();
      const isProcessing = status.includes('active') || status.includes('process');
      if (isNew && isProcessing) return true;
    }
    await new Promise(r => setTimeout(r, intervalMs));
  }
  return false;
}

/** Stage 2: Poll until the same criteria flips to Completed. */
async function pollUntilCompleted({search_term, location, minDateIso=null, timeoutMs=90000, intervalMs=2000}) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    const list = await loadBatchesAndReturn();
    const newest = findNewestForCriteria(list, search_term, location);
    if (newest) {
      const dc = newest.date_created || '';
      const isNew = !minDateIso || (dc && dc > minDateIso);
      const status = (newest.status || '').toLowerCase();
      if (isNew && status.includes('complet')) return true;
    }
    await new Promise(r => setTimeout(r, intervalMs));
  }
  return false;
}

/** Show leads for a batch */
async function showLeads(batch) {
  const leadsCard = document.getElementById('leadsCard');
  const title = document.getElementById('batchTitle');
  title.textContent = batch.batch_id || '';
  const tbody = document.querySelector('#leadsTable tbody');
  tbody.innerHTML = '';
  leadsCard.style.display = 'block';

  try {
    const url = `${BASE}/webhook/ui/leads?batch_id=${encodeURIComponent(batch.batch_id)}&client_id=${encodeURIComponent(CLIENT_ID)}`;
    const data = await fetchJSON(url);
    const rows = data.data || [];
    rows.forEach(l => {
      tbody.appendChild(h('tr',{},
        h('td',{}, l.name || 'N/A'),
        h('td',{}, l.phone || 'â€”'),
        h('td',{}, l.website ? h('a',{href:l.website,target:'_blank',class:'link'}, 'Website') : 'â€”'),
        h('td',{}, (l.rating || l.rating === 0) ? `â˜… ${l.rating}` : 'â€”'),
        h('td',{}, (l.reviews || l.reviews === 0) ? String(l.reviews) : 'â€”'),
        h('td',{}, l.address || 'â€”')
      ));
    });
    if (rows.length === 0) {
      tbody.appendChild(h('tr',{}, h('td',{colspan:'6',class:'empty-state'}, 'No leads found')));
    }
  } catch(e) {
    tbody.appendChild(h('tr',{}, h('td',{colspan:'6',class:'empty-state'}, `Error: ${e.message}`)));
  }
}

/** Re-run: two-stage polling (Processing â†’ Completed) */
async function rerun(b) {
  if (!confirm('Re-run scraping for this batch?')) return;
  const minDateIso = new Date().toISOString();
  const t = showToast({
    title: 'Re-run startedâ€¦',
    desc: 'Waiting for your scraping to enter processingâ€¦',
    variant: 'info',
    sticky: true
  });
  try {
    const res = await fetch(`${BASE}/webhook/rerun-scraping`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ record_id: b.record_id, client_id: CLIENT_ID })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    // Stage 1: wait until we see Processing
    const gotProcessing = await pollUntilProcessing({
      search_term: b.search_term,
      location: b.location,
      minDateIso,
      timeoutMs: 60000,
      intervalMs: 2000
    });

    if (gotProcessing) {
      t.update({ title:'Processingâ€¦', desc:'Your scraping is currently processing.', variant:'warn', autoCloseMs: 2000 });
    } else {
      t.update({ title:'Still queuingâ€¦', desc:'Processing not detected yet. Weâ€™ll keep watching for completion.', variant:'warn', autoCloseMs: 2500 });
    }

    // Stage 2: then wait until Completed
    const done = await pollUntilCompleted({
      search_term: b.search_term,
      location: b.location,
      minDateIso,
      timeoutMs: 120000,
      intervalMs: 2000
    });

    if (done) {
      showToast({ title:'Re-run completed', desc:'Latest batch is ready.', variant:'success', duration: 2800 });
    } else {
      showToast({ title:'Re-run queued', desc:'It will appear shortly. You can refresh anytime.', variant:'info', duration: 4200 });
    }
  } catch(e) {
    showToast({ title:'Re-run failed', desc:e.message, variant:'error', duration:5200 });
  }
}

/** Delete a batch by batch_id (and client_id) */
async function delBatch(b) {
  if (!confirm('Delete this batch and its leads?')) return;
  const t = showToast({ title:'Deletingâ€¦', desc:'Removing this batch.', variant:'info', sticky:true });
  try {
    const res = await fetch(`${BASE}/webhook/delete-batch`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ batch_id: b.batch_id, client_id: CLIENT_ID })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    await loadBatchesAndReturn();
    t.update({ title:'Deleted', desc:'The batch has been removed.', variant:'success', autoCloseMs:2400 });
  } catch(e) {
    t.update({ title:'Delete failed', desc:e.message, variant:'error', autoCloseMs:5200 });
  }
}

/** Submit new scrape: two-stage polling (Processing â†’ Completed) */
document.getElementById('scrapeForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const search_term = document.getElementById('search_term').value.trim();
  const location = document.getElementById('location').value.trim();
  if (!search_term || !location) return;

  const minDateIso = new Date().toISOString();
  const t = showToast({
    title: 'Scrape queuedâ€¦',
    desc: 'Waiting for your scraping to enter processingâ€¦',
    variant: 'info',
    sticky: true
  });

  try {
    const res = await fetch(`${BASE}/webhook/scrape-leads`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ search_term, location, client_id: CLIENT_ID })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    // Stage 1: wait until we see Processing
    const gotProcessing = await pollUntilProcessing({
      search_term,
      location,
      minDateIso,
      timeoutMs: 60000,
      intervalMs: 2000
    });

    if (gotProcessing) {
      t.update({ title:'Processingâ€¦', desc:'Your scraping is currently processing.', variant:'warn', autoCloseMs: 2000 });
    } else {
      t.update({ title:'Still queuingâ€¦', desc:'Processing not detected yet. Weâ€™ll keep watching for completion.', variant:'warn', autoCloseMs: 2500 });
    }

    // Stage 2: then wait until Completed
    const done = await pollUntilCompleted({
      search_term,
      location,
      minDateIso,
      timeoutMs: 120000,
      intervalMs: 2000
    });

    if (done) {
      showToast({ title:'Scrape completed', desc:'Your batch is ready.', variant:'success', duration: 2800 });
    } else {
      showToast({ title:'Scrape queued', desc:'It will appear shortly. You can refresh anytime.', variant:'info', duration: 4200 });
    }
  } catch(e) {
    showToast({ title:'Scrape failed', desc:e.message, variant:'error', duration:5200 });
  }
});

/** manual refresh */
document.getElementById('refreshBtn').addEventListener('click', loadBatchesAndReturn);

/** initial render */
loadBatchesAndReturn();
</script>
</body>
</html>
